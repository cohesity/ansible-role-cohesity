#!/usr/bin/python
# Copyright (c) 2018 Cohesity Inc
# Apache License Version 2.0

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.urls import open_url, urllib_error

try:
    # => When unit testing, we need to look in the correct location however, when run via ansible,
    # => the expectation is that the modules will live under ansible.
    from module_utils.storage.cohesity.cohesity_auth import get__cohesity_auth__token
    from module_utils.storage.cohesity.cohesity_utilities import cohesity_common_argument_spec, raise__cohesity_exception__handler
    from module_utils.storage.cohesity.cohesity_hints import get__prot_source_id__by_endpoint, \
        get__prot_source_root_id__by_environment, get__prot_policy_id__by_name, \
        get__storage_domain_id__by_name, get__protection_jobs__by_environment, \
        get__protection_run__all__by_id
except:
    from ansible.module_utils.storage.cohesity.cohesity_auth import get__cohesity_auth__token
    from ansible.module_utils.storage.cohesity.cohesity_utilities import cohesity_common_argument_spec, raise__cohesity_exception__handler
    from ansible.module_utils.storage.cohesity.cohesity_hints import get__prot_source_id__by_endpoint, \
        get__prot_source_root_id__by_environment, get__prot_policy_id__by_name, \
        get__storage_domain_id__by_name, get__protection_jobs__by_environment, \
        get__protection_run__all__by_id

ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'supported_by': 'community',
    'status': ['preview']
}

DOCUMENTATION = '''
module: cohesity_job
short_description: Management of Cohesity Protection Jobs
description:
    - Ansible Module used to register, remove, start, and stop the Cohesity Protection Job on a Cohesity Cluster.
    - When executed in a playbook, the Cohesity Protection Job will be validated and the appropriate state action
    - will be applied.
version_added: '2.6.5'
author:
  - Jeremy Goodrum (github.com/exospheredata)
  - Cohesity, Inc

options:
  state:
    description:
      - Determines the state of the Protection Job
    choices:
      - present
      - absent
      - started
      - stopped
    default: present
  name:
    description:
      - Name to assign to the Protection Job
    required: yes
  description:
    description:
      - Optional Description to assign to the Protection Job
  environment:
    description:
      - Specifies the environment type (such as VMware or SQL) of the Protection Source this Job
      - is protecting. Supported environment types include 'Physical', 'VMware'
    choices:
      - VMware
      - Physical
      - GenericNas
    required: yes
  protection_sources:
    description:
      - Valid list of endpoint names for existing Protection Sources to be included in the job. Required when I(state=present).
  protection_policy:
    description:
      - Valid policy name or ID for andexisting Protection Policy to be assigned to the job.
      - Required when I(state=present).
  storage_domain:
    description:
      - Existing Storage Domain to which the Protection Job will be associated. Required when I(state=present).
  time_zone:
    description:
      - Specifies the timezone to use when calculating time for this Protection Job such as the Job start time.
    default: 'America/Los_Angeles'
  start_time:
    description:
      - Specifies the registered start time for the Protection Job.  Format must be 24hr time in either HHMM or HH:MM style.
      - If not configured then the Cluster will automatically select a time.
  delete_backups:
    description:
      - Specifies if Snapshots generated by the Protection Job should also be deleted when the Job is deleted.
      - Optional and only valid when I(state=absent)
    type: bool
    default: no
  ondemand_run_type:
    description:
      - Specifies the type of OnDemand Backup.
    choices:
      - Regular
      - Full
      - Log
      - System
    default: 'Regular'
  cancel_active:
    description:
      - Specifies if Current Running Backup Job should be canceled.  If False, active jobs will not be stopped
      - and a failure will be raised.
      - Optional and only valid when I(state=stopped)
    type: bool
    default: no

extends_documentation_fragment:
    - cohesity
requirements: []
'''

EXAMPLES = '''
# Create a new Physical Server Protection Job
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: present
    name: myhost
    environment: Physical
    protection_sources:
      - myhost.domain.lab
    protection_policy: Bronze
    storage_domain: Default

# Create a new VMware Server Protection Job
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: present
    name: myvcenter
    environment: VMware
    protection_sources:
      - myvcenter.domain.lab
    protection_policy: Gold
    storage_domain: Default

# Remove an existing VMware Server Protection Job
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: absent
    name: myvcenter
    environment: VMware

# Remove an existing VMware Server Protection Job and remove all Backups
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: absent
    name: myvcenter
    environment: VMware
    delete_backups: True

# Start an existing VMware Server Protection Job
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: started
    name: myvcenter
    environment: VMware

# Stop an actively running VMware Server Protection Job
- cohesity_job:
    cluster: cohesity.lab
    username: admin
    password: password
    state: stopped
    name: myvcenter
    environment: VMware
'''

RETURN = '''
Returns the registered Protection Job ID
'''


class ParameterViolation(Exception):
    pass


class ProtectionException(Exception):
    pass


def check__mandatory__params(module):
    # => This method will perform validations of optionally mandatory parameters
    # => required for specific states and environments.
    success = True
    missing_params = list()
    environment = module.params.get('environment')

    if module.params.get('state') == 'present':
        action = 'creation'

        if not module.params.get('protection_sources'):
            success = False
            missing_params.append('protection_sources')
        if not module.params.get('protection_policy'):
            success = False
            missing_params.append('protection_policy')
        if not module.params.get('storage_domain'):
            success = False
            missing_params.append('storage_domain')

    else:
        action = 'remove'

    if not success:
        module.fail_json(
            msg="The following variables are mandatory for this action (" + action +
            ") when working with environment type (" + environment + ")",
            missing=missing_params
        )


def check__protection_job__exists(module, self):
    try:
        job_list = get__protection_jobs__by_environment(module, self)

        for job in job_list:
            if job['name'] == self['name']:
                return job['id']

        return False
    except urllib_error.URLError as e:
        # => Capture and report any error messages.
        raise__cohesity_exception__handler(e.read(), module)
    except Exception as error:
        raise__cohesity_exception__handler(error, module)


def wait__for_job_state__transition(module, self, job_runs, state='start'):
    if not job_runs:
        job_runs = []
    if state != 'start':
        state = 'stop'
    import time
    loop_cnt = 0
    while loop_cnt <= 20:
        payload = self.copy()
        # => If the backup finishes before we check, we need to look
        # => at previous backups to see if the last job is successful.
        payload['active_only'] = False
        if state == 'stop':
            # => If we are checking to see if the job is stopped, then
            # => Simply filtering out the active jobs will suffice.
            payload['active_only'] = True
        payload['is_deleted'] = False
        for job_run in job_runs:
            currently_active = get__protection_run__all__by_id(
                module, payload)
            if state == 'start':
                if currently_active:
                    status = currently_active[0][
                        'backupRun']['status'].lstrip('k')
                    valid_states = ['Accepted', 'Success']
                    for check_state in valid_states:
                        if status == check_state:
                            try:
                                job_runs.pop(job_run)
                            except:
                                if len(job_runs) == 1:
                                    job_runs = []
            else:
                if not currently_active:
                    try:
                        job_runs.pop(job_run)
                    except:
                        if len(job_runs) == 1:
                            job_runs = []
        if not job_runs:
            break
        else:
            time.sleep(5)
            loop_cnt += 1

    if loop_cnt == 21:
        module.fail_json(msg="Failed to successfully " + state + " the Cohesity Protection Job",
                         changed=False, id=self['id'], loop_cnt=loop_cnt)


def register_job(module, self):
    server = module.params.get('cluster')
    validate_certs = module.params.get('validate_certs')
    token = self['token']
    try:
        uri = "https://" + server + "/irisservices/api/v1/public/protectionJobs"
        headers = {"Accept": "application/json",
                   "Authorization": "Bearer " + token}
        payload = self.copy()

        # => Remove the Authorization Token from the Payload
        payload.pop('token', None)

        payload['environment'] = "k" + self['environment']

        data = json.dumps(payload)
        # module.exit_json(output=data)
        response = open_url(url=uri, data=data, headers=headers,
                            validate_certs=validate_certs)

        response = json.loads(response.read())

        # => This dictionary will allow us to return a standardized output
        # => for all Protection Job.
        output = dict(
            id=response['id'],
            name=response['name'],
            environment=response['environment'].lstrip('k'),
            priority=response['priority'].lstrip('k'),
            start_time=response['startTime']
        )

        return output
    except urllib_error.URLError as e:
        # => Capture and report any error messages.
        raise__cohesity_exception__handler(e.read(), module)
    except Exception as error:
        raise__cohesity_exception__handler(error, module)


def start_job(module, self):
    server = module.params.get('cluster')
    validate_certs = module.params.get('validate_certs')
    token = self['token']

    payload = self.copy()
    payload['active_only'] = True
    payload['is_deleted'] = False
    currently_active = get__protection_run__all__by_id(module, payload)
    if currently_active:
        results = dict(
            changed=False,
            msg="The Protection Job for this host is currently running",
            name=module.params.get('name')
        )
        module.exit_json(**results)

    try:
        uri = "https://" + server + \
            "/irisservices/api/v1/public/protectionJobs/run/" + str(self['id'])
        headers = {"Accept": "application/json",
                   "Authorization": "Bearer " + token}
        payload = dict()
        payload['name'] = self['name']
        payload['environment'] = self['environment']

        payload['runType'] = "k" + self['runType']

        data = json.dumps(payload)
        # module.exit_json(output=data)
        response = open_url(url=uri, data=data, headers=headers,
                            validate_certs=validate_certs)

        # => There is no data output so if we get a 204 then we are
        # => happy.
        if not response.getcode() == 204:
            raise ProtectionException(
                msg="Something went wrong with the attempt to start protection job %s" % self['id'])

        # => This dictionary will allow us to return a standardized output
        # => for all Protection Job.
        output = dict(
            id=self['id']
        )

        # => It can take a few moments for the job to actually stop.  In this case,
        # => We will introduce a delay and check every (5) seconds for up to a minute
        # => to see if the job stopped.
        wait__for_job_state__transition(
            module, self, [self['id']], state='start')

        return output
    except urllib_error.URLError as e:
        # => Capture and report any error messages.
        raise__cohesity_exception__handler(e.read(), module)
    except Exception as error:
        raise__cohesity_exception__handler(error, module)


def stop_job(module, self):
    server = module.params.get('cluster')
    validate_certs = module.params.get('validate_certs')
    token = self['token']

    payload = self.copy()
    payload['active_only'] = True
    payload['is_deleted'] = False
    currently_active = get__protection_run__all__by_id(module, payload)
    if not currently_active:
        results = dict(
            changed=False,
            msg="The Protection Job for this host is not currently running",
            name=module.params.get('name')
        )
        module.exit_json(**results)
    if not module.params.get('cancel_active') and currently_active:
        module.fail_json(
            changed=False, msg="The Protection Job for this host is active and cannot be stopped")
    try:
        uri = "https://" + server + \
            "/irisservices/api/v1/public/protectionRuns/cancel/" + \
            str(self['id'])
        headers = {"Accept": "application/json",
                   "Authorization": "Bearer " + token}
        payload = self.copy()

        # => Remove the Authorization Token from the Payload
        payload.pop('token', None)

        output = dict(
            id=self['id'],
            cancel_active=module.params.get('cancel_active'),
            jobRunIds=list()
        )
        for backup_run in currently_active:
            payload['jobRunId'] = backup_run['backupRun']['jobRunId']

            data = json.dumps(payload)
            # module.exit_json(output=data)
            response = open_url(url=uri, data=data, headers=headers,
                                validate_certs=validate_certs)

            # => There is no data output so if we get a 204 then we are
            # => happy.
            if not response.getcode() == 204:
                raise ProtectionException(
                    msg="Something went wrong with the attempt to cancel protection job %s" % str(self['id']))

            # => This dictionary will allow us to return a standardized output
            # => for all Protection Job.
            output['jobRunIds'].append(payload['jobRunId'])

        # => It can take a few moments for the job to actually stop.  In this case,
        # => We will introduce a delay and check every (5) seconds for up to a minute
        # => to see if the job stopped.
        wait__for_job_state__transition(
            module, self, output['jobRunIds'], state='stop')

        return output
    except urllib_error.URLError as e:
        # => Capture and report any error messages.
        raise__cohesity_exception__handler(e.read(), module)
    except Exception as error:
        raise__cohesity_exception__handler(error, module)


def unregister_job(module, self):
    server = module.params.get('cluster')
    validate_certs = module.params.get('validate_certs')
    token = self['token']
    try:
        uri = "https://" + server + \
            "/irisservices/api/v1/public/protectionJobs/" + str(self['id'])
        headers = {"Accept": "application/json",
                   "Authorization": "Bearer " + token}

        payload = dict(
            deleteSnapshots=self['deleteSnapshots']
        )
        data = json.dumps(payload)

        response = open_url(url=uri, method='DELETE', data=data, headers=headers,
                            validate_certs=validate_certs)

        return response
    except urllib_error.URLError as e:
        # => Capture and report any error messages.
        raise__cohesity_exception__handler(e.read(), module)
    except Exception as error:
        raise__cohesity_exception__handler(error, module)


def main():
    # => Load the default arguments including those specific to the Cohesity Protection Jobs.
    argument_spec = cohesity_common_argument_spec()
    argument_spec.update(
        dict(
            state=dict(choices=['present', 'absent',
                                'started', 'stopped'], default='present'),
            name=dict(type='str', required=True),
            description=dict(type='str'),
            # => Currently, the only supported environments types are list in the choices
            # => For future enhancements, the below list should be consulted.
            # => 'SQL', 'View', 'Puppeteer', 'Pure', 'Netapp', 'HyperV', 'Acropolis', 'Azure'
            environment=dict(
                choices=['VMware', 'Physical', 'GenericNas'],
                required=True
            ),
            protection_sources=dict(type='list'),
            protection_policy=dict(type='str'),
            storage_domain=dict(type='str'),
            time_zone=dict(type='str', default='America/Los_Angeles'),
            start_time=dict(type='str'),
            delete_backups=dict(type='bool', default=False),
            ondemand_run_type=dict(
                choices=['Regular', 'Full', 'Log', 'System'], default='Regular'),
            cancel_active=dict(type='bool', default=False)
        )
    )

    # => Create a new module object
    module = AnsibleModule(argument_spec=argument_spec,
                           supports_check_mode=True)
    results = dict(
        changed=False,
        msg="Attempting to manage Protection Source",
        state=module.params.get('state')
    )

    job_details = dict(
        token=get__cohesity_auth__token(module),
        name=module.params.get('name'),
        description=module.params.get('description'),
        environment=module.params.get('environment'),
        sourceIds=module.params.get('protection_sources'),
        policyId=module.params.get('protection_policy'),
        viewBoxId=module.params.get('storage_domain'),
        timezone=module.params.get('time_zone')
    )

    job_exists = check__protection_job__exists(module, job_details)

    if module.check_mode:
        check_mode_results = dict(
            changed=False,
            msg="Check Mode: Cohesity Protection Job is not currently registered",
            id=""
        )
        if module.params.get('state') == "present":
            if job_exists:
                check_mode_results[
                    'msg'] = "Check Mode: Cohesity Protection Job is currently registered.  No changes"
            else:
                check_mode_results[
                    'msg'] = "Check Mode: Cohesity Protection Job is not currently registered.  This action would register the Cohesity Protection Job."
                check_mode_results['id'] = job_exists
        else:
            if job_exists:
                check_mode_results[
                    'msg'] = "Check Mode: Cohesity Protection Job is currently registered.  This action would unregister the Cohesity Protection Job."
                check_mode_results['id'] = job_exists
            else:
                check_mode_results[
                    'msg'] = "Check Mode: Cohesity Protection Job is not currently registered.  No changes."
        module.exit_json(**check_mode_results)

    elif module.params.get('state') == "present":

        results['source_vars'] = job_details

        if job_exists:
            results = dict(
                changed=False,
                msg="The Protection Job for this host is already registered",
                id=job_exists,
                name=module.params.get('name')
            )
        else:
            check__mandatory__params(module)

            job_details['sourceIds'] = list()
            prot_source = dict(
                environment=job_details['environment'],
                token=job_details['token']
            )
            for source in module.params.get('protection_sources'):
                prot_source['endpoint'] = source
                source_id = get__prot_source_id__by_endpoint(
                    module, prot_source)
                if source_id:
                    job_details['sourceIds'].append(source_id)
            job_details['parentSourceId'] = get__prot_source_root_id__by_environment(
                module, job_details)

            job_details['policyId'] = get__prot_policy_id__by_name(
                module, job_details)

            job_details['viewBoxId'] = get__storage_domain_id__by_name(
                module, job_details)

            if module.params.get('start_time'):
                start_time = list(module.params.get(
                    'start_time').replace(":", ""))
                if not len(start_time) == 4:
                    # => There are only so many options here but if we get more characters
                    # => than four then we need to escape quickly.
                    module.fail_json(msg="Invalid start_time selected (" + module.params.get(
                        'start_time') + ").  Please review and submit the correct Protection Job Starting time.")
                job_details['startTime'] = dict(
                    hour=start_time[0] + start_time[1],
                    minute=start_time[2] + start_time[3]
                )

            response = register_job(module, job_details)

            results = dict(
                changed=True,
                msg="Registration of Cohesity Protection Job Complete",
                **response
            )

    elif module.params.get('state') == "absent":
        if job_exists:
            job_details['id'] = job_exists
            job_details['deleteSnapshots'] = module.params.get(
                'delete_backups')

            response = unregister_job(module, job_details)

            results = dict(
                changed=True,
                msg="Unregistration of Cohesity Protection Job Complete",
                id=job_exists,
                name=module.params.get('name')
            )
        else:
            results = dict(
                changed=False,
                msg="The Protection Job for this host is currently not registered",
                name=module.params.get('name')
            )

    elif module.params.get('state') == "started":
        if job_exists:
            job_details['id'] = job_exists
            job_details['runType'] = module.params.get(
                'ondemand_run_type')

            response = start_job(module, job_details)

            results = dict(
                changed=True,
                msg="The Protection Job for this host has been started",
                id=job_exists,
                name=module.params.get('name')
            )
        else:
            results = dict(
                changed=False,
                msg="The Protection Job for this host is currently not registered",
                name=module.params.get('name')
            )

    elif module.params.get('state') == "stopped":
        if job_exists:
            job_details['id'] = job_exists

            response = stop_job(module, job_details)

            results = dict(
                changed=True,
                msg="The Protection Job for this host has been stopped",
                id=job_exists,
                name=module.params.get('name')
            )
        else:
            results = dict(
                changed=False,
                msg="The Protection Job for this host is currently not registered",
                name=module.params.get('name')
            )
    else:
        # => This error should never happen based on the set assigned to the parameter.
        # => However, in case, we should raise an appropriate error.
        module.fail_json(msg="Invalid State selected: {0}".format(
            module.params.get('state')), changed=False)

    module.exit_json(**results)


if __name__ == '__main__':
    main()
